{{define "common/network"}}{{template "common/header" .}} {{if ts .CustomCode}} {{.CustomCode|safe}} {{end}}{{template "common/menu" .}}
<div id="network" class="nb-container">
    <div class="ui container">
        <div class="service-status">
            <div class="ui icon button"
                 v-for='server in servers'
                 :id="server.ID"
                 style="margin-top: 3px"
                 @click="redirectNetwork(server.ID)">
                @#server.Name#@<i :class="server.Host.CountryCode + ' flag'"></i>&nbsp;<i
                    v-if='server.Host.Platform == "darwin"' class="apple icon"></i><i
                    v-else-if='isWindowsPlatform(server.Host.Platform)' class="windows icon"></i><i
                    v-else :class="'fl-' + getFontLogoClass(server.Host.Platform)"></i>
                </div>
            <div ref="chartDom" style="border-radius: 28px; margin-top: 15px;height: 520px;max-width: 1400px;overflow: hidden"></div>
        </div>
    </div>
</div>

{{template "common/footer" .}}
<script>
        const monitorInfo =  JSON.parse('{{.MonitorInfos}}');
        const initData = JSON.parse('{{.Servers}}').servers;
        // 基于准备好的dom，初始化echarts实例
        // var myChart = echarts.init(document.getElementById('monitor-info-container'));
        // 使用刚指定的配置项和数据显示图表。
        var statusCards = new Vue({
            el: '#network',
            delimiters: ['@#', '#@'],
            data: {
                servers: initData,
                cache: [],
                option: {
                    tooltip: {
                        trigger: 'axis',
                        position: function (pt) {
                            return [pt[0], '10%'];
                        },
                        formatter: function(params){
                            let result = params[0].axisValueLabel + "<br />";
                            params.forEach(function(item){
                                result += item.marker + item.seriesName + ": " + item.value[1].toFixed(2) + " ms<br />";
                             })
                            return result;
                        },
                        confine: true,
                        transitionDuration: 0
                    },
                    title: {
                        left: 'center',
                        text: "",
                        textStyle: {}
                    },
                    legend: {
                        top: '5%',
                        data: [],
                        textStyle: {
                            fontSize: 14
                        }
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.8)',
                    toolbox: {
                        feature: {
                            dataZoom: {
                                yAxisIndex: 'none'
                            },
                            restore: {},
                            saveAsImage: {}
                        }
                    },
                    dataZoom: [
                        {
                            start: 94,
                            end: 100
                        }
                    ],
                    xAxis: {
                        type: 'time',
                        boundaryGap: false
                    },
                    yAxis: {
                        type: 'value',
                        boundaryGap: [0, '100%']
                    },
                    series: [],
                },
                isHover: false,
                chartOnOff: true
            },
            mounted() {
                 this.renderChart();
                 this.parseMonitorInfo(monitorInfo);
                 this.myChart.on('legendselectchanged', function(obj) {
                  var selected = obj.selected;
                  var legend = obj.name;
                  // 使用 legendToggleSelect Action 会重新触发 legendselectchanged Event，导致本函数重复运行
                  // 使得 无 selected 对象
                  var vm = network.__vue__;
                  if (selected != undefined && vm.isFirstUnSelect(selected) && vm.chartOnOff) {
                    vm.triggerAction('legendToggleSelect', selected);
                    vm.chartOnOff = false;
                  }
                });
            },
            methods: {
                redirectNetwork(id) {
                    this.getMonitorHistory(id)
                    .then(function(monitorInfo) {
                          var vm = network.__vue__;
                          vm.parseMonitorInfo(monitorInfo);
                    })
                    .catch(function(error){
                        window.location.href = "/404";
                    })
                },
                getMonitorHistory(id) {
                      return $.ajax({
                        url: "/api/v1/monitor/"+id,
                        method: "GET"
                      });
                },
                parseMonitorInfo(monitorInfo) {
                    let tSeries = [];
                    let tLegendData = [];
                    for (let i = 0; i < monitorInfo.result.length; i++) {
                        let data = [];
                        for (let j = 0; j < monitorInfo.result[i].created_at.length; j++) {
                            data.push([monitorInfo.result[i].created_at[j],monitorInfo.result[i].avg_delay[j]]);
                        }
                        tLegendData.push(monitorInfo.result[i].monitor_name);
                        tSeries.push({
                                name: monitorInfo.result[i].monitor_name,
                                type: 'line',
                                smooth: true,
                                symbol: 'none',
                                data: data
                        });
                    }
                    this.option.title.text = monitorInfo.result[0].server_name;
                    this.option.series = tSeries;
                    this.option.legend.data = tLegendData;
                    this.myChart.clear();
                    this.myChart.setOption(this.option);
                },
                isWindowsPlatform(str) {
                    return str.includes('Windows')
                },
                getFontLogoClass(str) {
                    if (["almalinux",
                        "alpine",
                        "aosc",
                        "apple",
                        "archlinux",
                        "archlabs",
                        "artix",
                        "budgie",
                        "centos",
                        "coreos",
                        "debian",
                        "deepin",
                        "devuan",
                        "docker",
                        "elementary",
                        "fedora",
                        "ferris",
                        "flathub",
                        "freebsd",
                        "gentoo",
                        "gnu-guix",
                        "illumos",
                        "kali-linux",
                        "linuxmint",
                        "mageia",
                        "mandriva",
                        "manjaro",
                        "nixos",
                        "openbsd",
                        "opensuse",
                        "pop-os",
                        "raspberry-pi",
                        "redhat",
                        "rocky-linux",
                        "sabayon",
                        "slackware",
                        "snappy",
                        "solus",
                        "tux",
                        "ubuntu",
                        "void",
                        "zorin"].indexOf(str)
                        > -1) {
                    return str;
                    }
                },
                renderChart() {
                  this.myChart = echarts.init(this.$refs.chartDom);
                  this.myChart.setOption(this.option);
                },
                triggerAction(action, selected) {
                  legend = [];
                  for (name in selected) {
                    if (selected.hasOwnProperty(name)) {
                      legend.push({
                        name: name
                      });
                    }
                  }

                  this.myChart.dispatchAction({
                    type: action,
                    batch: legend
                  });
                },
                isFirstUnSelect(selected) {
                  var unSelectedCount = 0;
                  for (name in selected) {
                    if (!selected.hasOwnProperty(name)) {
                      continue;
                    }
                    if (selected[name] == false) {
                      unSelectedCount++;
                    }
                  }
                  return unSelectedCount == 1;
                },
            },
            beforeDestroy() {
                this.myChart.dispose();
                this.myChart = null;
              },
        });
</script>
{{end}}
